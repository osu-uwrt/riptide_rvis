#include "riptide_rviz/ControlPanel.hpp"
#include <iostream>
#include <filesystem>

namespace riptide_rviz
{
    ControlPanel::ControlPanel(QWidget *parent) : rviz_common::Panel(parent)
    {
        setFocusPolicy(Qt::ClickFocus);

        uiPanel = new Ui_ControlPanel();
        uiPanel->setupUi(this);

        // grab the rviz node
        nodeHandle = std::make_shared<rclcpp::Node>("riptide_rviz_control");

        // refresh UI elements so they start displayed correctly
        bringupListRefresh();

        // connect the UI signals
        connect(uiPanel->bringupRefresh, &QPushButton::clicked, [this](void)
                { bringupListRefresh(); });
        connect(uiPanel->bringupHost, SIGNAL(currentIndexChanged(int)), SLOT(handleBringupHost(int)));
    }

    void ControlPanel::load(const rviz_common::Config &config)
    {
        rviz_common::Panel::load(config);
    }

    void ControlPanel::save(rviz_common::Config config) const
    {
        rviz_common::Panel::save(config);
    }

    bool ControlPanel::event(QEvent *event)
    {
    }

    ControlPanel::~ControlPanel()
    {
        // master window control removal
        delete uiPanel;
    }

    void ControlPanel::bringupListRefresh()
    {
        // get the list of nodes available
        std::vector<std::string> names = nodeHandle->get_node_names();

        // clear the entries in the combo boxes
        uiPanel->bringupHost->clear();

        // filter names down to launch nodes
        std::vector<std::string> launchNodes;
        auto filt = [](const auto &s)
        { return s.find("launch_srv") != std::string::npos; };
        std::copy_if(names.begin(), names.end(), std::back_inserter(launchNodes), filt);

        // make sure we have availiable nodes in the list, otherwise place a blank list entry
        if (launchNodes.size() > 0)
        {
            for (std::string const &name : launchNodes)
            {
                // push these into the combo box
                uiPanel->bringupHost->addItem(QString::fromStdString(name.substr(0, name.find_last_of('l')-1)));
            }
            uiPanel->bringupStart->setDisabled(false);
        }
        else
        {
            uiPanel->bringupHost->addItem("None");
            uiPanel->bringupStart->setDisabled(true);
        }

        // clear the list of bringup files
        uiPanel->bringupFile->clear();

        // populate with new files
        std::string bringupFilesDir = ament_index_cpp::get_package_share_directory("riptide_bringup2") + "/launch";
        for (const auto &entry : std::filesystem::directory_iterator(bringupFilesDir))
        {
            std::string file = std::string(entry.path());
            if (file.find(".launch.py") != std::string::npos)
            {
                uiPanel->bringupFile->addItem(QString::fromStdString(file.substr(file.find_last_of('/') + 1)));
            }
        }
    }

    void ControlPanel::handleBringupHost(int selection)
    {
        std::string targetNode = uiPanel->bringupHost->itemText(selection).toStdString();
        std::cout << "Targeting host " << targetNode << std::endl;

        // make sure the event wasnt generated by us
        if(targetNode != "None"){

            // overwrite the old clients
            bringupStartClient = nodeHandle->create_client<launch_msgs::srv::StartLaunch>(targetNode +"/start_launch");
            bringupListClient = nodeHandle->create_client<launch_msgs::srv::ListLaunch>(targetNode +"/list_launch");
            bringupStopClient = nodeHandle->create_client<launch_msgs::srv::StopLaunch>(targetNode +"/stop_launch");
        } 
    }

} // namespace riptide_rviz

#include <pluginlib/class_list_macros.hpp> // NOLINT
PLUGINLIB_EXPORT_CLASS(riptide_rviz::ControlPanel, rviz_common::Panel);