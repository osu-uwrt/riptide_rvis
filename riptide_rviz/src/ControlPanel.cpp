#include "riptide_rviz/ControlPanel.hpp"
#include <iostream>
#include <filesystem>
#include <chrono>
#include <string>

using namespace std::chrono_literals;

namespace riptide_rviz
{
    ControlPanel::ControlPanel(QWidget *parent) : rviz_common::Panel(parent)
    {
        setFocusPolicy(Qt::ClickFocus);

        uiPanel = new Ui_ControlPanel();
        uiPanel->setupUi(this);

        // grab the rviz node
        nodeHandle = std::make_shared<rclcpp::Node>("riptide_rviz_control");

        // create and cancel the bringup timer
        bringupCheckTimer = nodeHandle->create_wall_timer(100ms, std::bind(&ControlPanel::checkBringupStatus, this));
        bringupCheckTimer->cancel();

        // refresh UI elements so they start displayed correctly
        bringupListRefresh();

        // connect the UI signals
        connect(uiPanel->bringupRefresh, &QPushButton::clicked, [this](void)
                { bringupListRefresh(); });
        connect(uiPanel->bringupHost, SIGNAL(currentIndexChanged(int)), SLOT(handleBringupHost(int)));
    }

    void ControlPanel::load(const rviz_common::Config &config)
    {
        rviz_common::Panel::load(config);
    }

    void ControlPanel::save(rviz_common::Config config) const
    {
        rviz_common::Panel::save(config);
    }

    bool ControlPanel::event(QEvent *event)
    {
    }

    ControlPanel::~ControlPanel()
    {
        // master window control removal
        delete uiPanel;
    }

    void ControlPanel::bringupListRefresh()
    {
        // get the list of nodes available
        std::vector<std::string> names = nodeHandle->get_node_names();

        // clear the entries in the combo boxes
        uiPanel->bringupHost->clear();

        // filter names down to launch nodes
        std::vector<std::string> launchNodes;
        auto filt = [](const auto &s)
        { return s.find("launch_srv") != std::string::npos; };
        std::copy_if(names.begin(), names.end(), std::back_inserter(launchNodes), filt);

        // make sure we have availiable nodes in the list, otherwise place a blank list entry
        if (launchNodes.size() > 0)
        {
            uiPanel->bringupHost->addItem("None Selected");
            for (std::string const &name : launchNodes)
            {
                // push these into the combo box
                uiPanel->bringupHost->addItem(QString::fromStdString(name.substr(0, name.find_last_of('l') - 1)));
            }
            uiPanel->bringupStart->setDisabled(false);
        }
        else
        {
            uiPanel->bringupHost->addItem("None");
            uiPanel->bringupStart->setDisabled(true);
        }

        // clear the list of bringup files
        uiPanel->bringupFile->clear();
        uiPanel->bringupFile->addItem("None Selected");

        // populate with new files
        std::string bringupFilesDir = ament_index_cpp::get_package_share_directory(BRINGUP_PKG) + "/launch";
        for (const auto &entry : std::filesystem::directory_iterator(bringupFilesDir))
        {
            std::string file = std::string(entry.path());
            if (file.find(".launch.py") != std::string::npos)
            {
                uiPanel->bringupFile->addItem(QString::fromStdString(file.substr(file.find_last_of('/') + 1)));
            }
        }
    }

    void ControlPanel::handleBringupHost(int selection)
    {
        std::string targetNode = uiPanel->bringupHost->itemText(selection).toStdString();
        std::cout << "Targeting host " << targetNode << std::endl;

        // make sure the event wasnt generated by us
        if (targetNode != "None Selected")
        {

            // overwrite the old clients
            bringupStartClient = nodeHandle->create_client<launch_msgs::srv::StartLaunch>(targetNode + "/start_launch");
            bringupListClient = nodeHandle->create_client<launch_msgs::srv::ListLaunch>(targetNode + "/list_launch");
            bringupStopClient = nodeHandle->create_client<launch_msgs::srv::StopLaunch>(targetNode + "/stop_launch");
        }
    }

    void ControlPanel::startBringup()
    {
        // make sure that the bringup file is selected
        std::string targetFile = uiPanel->bringupFile->currentText().toStdString();

        // validate selection
        if (targetFile != "None" && targetFile != "None Selected")
        {
            // disable the start button and enable the stop button
            uiPanel->bringupStart->setDisabled(true);
            uiPanel->bringupStop->setDisabled(false);
            uiPanel->bringupRefresh->setDisabled(true);

            launch_msgs::srv::StartLaunch::Request::SharedPtr startReq = std::make_shared<launch_msgs::srv::StartLaunch::Request>();
            startReq->launch_file = targetFile;
            startReq->package = BRINGUP_PKG;

            while (bringupStartClient->wait_for_service(100ms))
            {
                if (!rclcpp::ok())
                    return;

                rclcpp::spin_some(nodeHandle);
            }

            auto future = bringupStartClient->async_send_request(startReq);
            if (rclcpp::spin_until_future_complete(nodeHandle, future) == rclcpp::FutureReturnCode::SUCCESS)
            {
                // check if the service started the bringup sucessfully
                if (future.get()->started)
                {
                    RCLCPP_INFO(nodeHandle->get_logger(), "Client accepted with launch ID: %s", std::to_string(future.get()->formed_launch.launch_id).c_str());

                    // record the bringup id
                    bringupID = future.get()->formed_launch.launch_id;

                    // start the check timer to make sure the service is still alive
                    bringupCheckTimer->reset();

                    // bail out of the function
                    return;
                }
            }

            RCLCPP_ERROR(nodeHandle->get_logger(), "ROS Launch service failed to start bringup");
            bringupID = -1;

            // reset the buttons durig an error
            uiPanel->bringupStart->setDisabled(false);
            uiPanel->bringupStop->setDisabled(true);
            uiPanel->bringupRefresh->setDisabled(false);
        }
    }

    void ControlPanel::checkBringupStatus()
    {
        launch_msgs::srv::ListLaunch::Request::SharedPtr startReq = std::make_shared<launch_msgs::srv::ListLaunch::Request>();
        startReq->status = launch_msgs::msg::LaunchID::RUNNING;

        while (bringupListClient->wait_for_service(100ms))
        {
            if (!rclcpp::ok())
                return;

            rclcpp::spin_some(nodeHandle);
        }

        auto future = bringupListClient->async_send_request(startReq);
        if (rclcpp::spin_until_future_complete(nodeHandle, future) == rclcpp::FutureReturnCode::SUCCESS)
        {
            // find the launch ID we want
            for(auto launch : future.get()->launches){
                if(launch.launch_id == bringupID){
                    // we found the one we want

                    if(launch.status != launch.RUNNING){
                        // launch has died, reset buttons
                        uiPanel->bringupStart->setDisabled(false);
                        uiPanel->bringupStop->setDisabled(true);
                        uiPanel->bringupRefresh->setDisabled(false);
                    }
                }
            }
        }
    }

} // namespace riptide_rviz

#include <pluginlib/class_list_macros.hpp> // NOLINT
PLUGINLIB_EXPORT_CLASS(riptide_rviz::ControlPanel, rviz_common::Panel);